<!DOCTYPE html>

<html>

<head>
    <title>RayTracing</title>
    <script type="text/javascript" src="js/three_69.js"></script>
    <script type="text/javascript" src="js/Stats.js"></script>
    <script type="text/javascript" src="js/dat.gui.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="Stats-output">
</div>
<div id="WebGL-output">
</div>

<script type="text/javascript">

    function init() {

        var stats = initStats();

        var scene = new THREE.Scene();
        var sceneCube = new THREE.Scene();

        var camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        var cameraCube = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);

        var webGLRenderer = new THREE.WebGLRenderer();
        webGLRenderer.setClearColor(new THREE.Color(0xEEEEEE, 1.0));
        webGLRenderer.setSize(window.innerWidth, window.innerHeight);
        webGLRenderer.shadowMapEnabled = false;
        webGLRenderer.autoClear = false;


        //创建所处的盒子,shaderLib为一种特殊的着色器
        var textureCube = createCubeMap();

        var shader = THREE.ShaderLib["cube"];
        shader.uniforms["tCube"].value = textureCube;
        var material = new THREE.ShaderMaterial({
            fragmentShader: shader.fragmentShader,
            vertexShader: shader.vertexShader,
            uniforms: shader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
        });

        cubeMesh = new THREE.Mesh(new THREE.BoxGeometry(100, 100, 100), material);
        sceneCube.add(cubeMesh);


        var t = THREE.ImageUtils.loadTexture("images/Texture/general/plaster.jpg" );

        var cyliGeo=new THREE.CylinderGeometry(10,10,10);
        var cyliMat=new THREE.MeshLambertMaterial({map:t});
        var cyli=new THREE.Mesh(cyliGeo,cyliMat);
        cyli.material.envMap=textureCube;
        cyli.position.x=0;
        cyli.position.y=1;
        scene.add(cyli);
//右边Phong
        var sphereGeo=new THREE.SphereGeometry(10, 15, 15);
        var sphereMat=new THREE.MeshPhongMaterial({map:t});
        var sphere = new THREE.Mesh(sphereGeo,sphereMat);
        sphere.material.envMap = textureCube;//把材质的envMap属性变为盒子的Texture
        sphere.rotation.y = -0.5;
        sphere.position.x = 22;
        sphere.position.y = 5;
        scene.add(sphere);
//左边Lambert
        var sphereGeo2=new THREE.SphereGeometry(10, 15, 15);
        var sphereMat2=new THREE.MeshLambertMaterial({map:t});
        var sphere2 = new THREE.Mesh(sphereGeo2,sphereMat2);
        sphere2.material.envMap = textureCube;//把材质的envMap属性变为盒子的Texture
        sphere2.rotation.y = -0.5;
        sphere2.position.x = -22;
        sphere2.position.y = 5;
        scene.add(sphere2);

        camera.position.x = 0;
        camera.position.y = 12;
        camera.position.z = 68;
        camera.lookAt(new THREE.Vector3(0, 0, 0));

//        添加光源
        var ambiLight = new THREE.AmbientLight(0xffffff);
        scene.add(ambiLight);

        var light = new THREE.SpotLight();
        light.position.set(0, 30, 30);
        light.intensity = 1.2;
        scene.add(light);

        var pointColor = "#ff5808";
        var directionalLight = new THREE.PointLight(pointColor);
        directionalLight.intensity = 4.5;
        scene.add(directionalLight);

        //用于模拟光源
        var sphereLight = new THREE.SphereGeometry(0.2);
        var sphereLightMaterial = new THREE.MeshBasicMaterial({color: 0xac6c25});
        var sphereLightMesh = new THREE.Mesh(sphereLight, sphereLightMaterial);
        sphereLightMesh.castShadow = true;
        sphereLightMesh.position.copy(new THREE.Vector3(3, 3, 3));
        scene.add(sphereLightMesh);


        document.getElementById("WebGL-output").appendChild(webGLRenderer.domElement);

        var step = 0;


        var controls = new function () {
            this.reflectivity = 1;
            this.rotate = false;

            this.updateBump = function (e) {
                cyli.material.reflectivity = controls.reflectivity;
                sphere.material.reflectivity = controls.reflectivity;
                sphere2.material.reflectivity = controls.reflectivity;

            }
        };


        var gui = new dat.GUI();
        gui.add(controls, "reflectivity", 0, 2).onChange(controls.updateBump);
        gui.add(controls, "rotate");

        render();




//输入盒子的六面
        function createCubeMap() {

            var path = "images/Texture/cubemap/Storforsen/";
            var format = '.jpg';
            var urls = [
                path + 'posx' + format, path + 'negx' + format,
                path + 'posy' + format, path + 'negy' + format,
                path + 'posz' + format, path + 'negz' + format
            ];

            var textureCube = THREE.ImageUtils.loadTextureCube(urls, new THREE.CubeReflectionMapping());
            return textureCube;
        }

        var invert = 1;
        var phase = 0;

        var mouseX = 0;
        var mouseY = 0;

        document.addEventListener('mousemove', onDocumentMouseMove, false);
        function onDocumentMouseMove(event) {

            mouseX = ( event.clientX - window.innerWidth / 2 ) * 10;
            mouseY = ( event.clientY - window.innerHeight / 2 ) * 10;

        }

        function render() {
            stats.update();
            step += 0.1;

            if (controls.rotate) {
                sphere.rotation.y -= 0.01;
                sphere2.rotation.y += 0.01;
            }


            if (phase > 2 * Math.PI) {
                invert = invert * -1;
                phase -= 2 * Math.PI;
            } else {
                phase += 0.03;
            }

            sphereLightMesh.position.z = +(21 * (Math.sin(phase)));
            sphereLightMesh.position.x = -14 + (14 * (Math.cos(phase)));

            if (invert < 0) {
                var pivot = 0;
                sphereLightMesh.position.x = (invert * (sphereLightMesh.position.x - pivot)) + pivot;
            }

            directionalLight.position.copy(sphereLightMesh.position);

            camera.position.x = (mouseX * .018);
            camera.position.y = 6 + (mouseY * .018);


            camera.lookAt(scene.position);
            cameraCube.rotation = camera.rotation;


            requestAnimationFrame(render);
            webGLRenderer.render(sceneCube, cameraCube);
            webGLRenderer.render(scene, camera);
        }


        function initStats() {

            var stats = new Stats();
//            stats.setMode(0); // 0: fps, 1: ms

            // Align top-left
            stats.domElement.style.position = 'absolute';
            stats.domElement.style.left = '0px';
            stats.domElement.style.top = '0px';

            document.getElementById("Stats-output").appendChild(stats.domElement);

            return stats;
        }
    };

    window.onload = init;


</script>
</body>
</html>